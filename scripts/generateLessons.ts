// scripts/generateLessons.ts
import fs from "node:fs/promises";
import path from "node:path";

import { LANGUAGES } from "../lib/languages";
import { LESSONS, type Lesson } from "../lib/lessons.source";

const apiKey = process.env.OPENAI_API_KEY;
if (!apiKey) throw new Error("Missing OPENAI_API_KEY in environment.");

type Job = {
  id: string;
  text: string;
  fromLang: string;
  toLang: string;
};

type Result = {
  id: string;
  translatedText: string;
  targetLang: string;
};

async function translateManyDirect(items: Job[]): Promise<Result[]> {
  const system =
    "You are a translation engine. Return only valid JSON matching the schema. No extra keys, no commentary.";

  const user = `Translate each item.text from item.fromLang to item.toLang.
Return results preserving the same id for each item.

items:
${JSON.stringify(items, null, 2)}`;

  const resp = await fetch("https://api.openai.com/v1/chat/completions", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${apiKey}`,
    },
    body: JSON.stringify({
      model: "gpt-4o-mini",
      temperature: 0,
      response_format: {
        type: "json_schema",
        json_schema: {
          name: "translate_many",
          strict: true,
          schema: {
            type: "object",
            additionalProperties: false,
            properties: {
              results: {
                type: "array",
                items: {
                  type: "object",
                  additionalProperties: false,
                  properties: {
                    id: { type: "string" },
                    translatedText: { type: "string" },
                    targetLang: { type: "string" },
                  },
                  required: ["id", "translatedText", "targetLang"],
                },
              },
            },
            required: ["results"],
          },
        },
      },
      messages: [
        { role: "system", content: system },
        { role: "user", content: user },
      ],
    }),
    cache: "no-store",
  });

  if (!resp.ok) {
    const t = await resp.text();
    throw new Error(`OpenAI error ${resp.status}: ${t}`);
  }

  const data = await resp.json();
  const content = data?.choices?.[0]?.message?.content?.toString()?.trim() ?? "";
  if (!content) throw new Error("No content returned from OpenAI.");

  const parsed = JSON.parse(content) as { results: Result[] };
  return Array.isArray(parsed?.results) ? parsed.results : [];
}

function deepClone<T>(v: T): T {
  return JSON.parse(JSON.stringify(v));
}

async function main() {
  const lessons: Lesson[] = deepClone(LESSONS);

  const languageCodes = LANGUAGES.map((l) => l.code);

  // Build jobs: for every phrase, fill missing codes using en-US as seed
  const jobs: Job[] = [];

  for (const lesson of lessons) {
    for (const phrase of lesson.phrases) {
      const seed = phrase.texts["en-US"] ?? Object.values(phrase.texts)[0] ?? "";
      if (!seed) continue;

      // Ensure en-US exists
      phrase.texts["en-US"] = phrase.texts["en-US"] ?? seed;

      for (const code of languageCodes) {
        if (phrase.texts[code]) continue; // already filled
        if (code === "en-US") continue;

        jobs.push({
          id: `${lesson.id}|${phrase.id}|${code}`,
          text: seed,
          fromLang: "en-US",
          toLang: code,
        });
      }
    }
  }

  // Batch to keep request size sane
  const BATCH_SIZE = 40;

  for (let i = 0; i < jobs.length; i += BATCH_SIZE) {
    const batch = jobs.slice(i, i + BATCH_SIZE);
    console.log(`Translating batch ${i / BATCH_SIZE + 1} (${batch.length} items)...`);

    const results = await translateManyDirect(batch);

    // Apply results back into lessons
    for (const r of results) {
      const [lessonId, phraseId, langCode] = r.id.split("|");
      const lesson = lessons.find((l) => l.id === lessonId);
      const phrase = lesson?.phrases.find((p) => p.id === phraseId);
      if (!phrase) continue;
      phrase.texts[langCode] = r.translatedText;
    }
  }

  const output = `/* AUTO-GENERATED FILE. DO NOT EDIT BY HAND.
   Generated by scripts/generateLessons.ts
*/
export type LessonPhrase = { id: string; texts: Record<string, string> };
export type Lesson = { id: string; title: string; description: string; phrases: LessonPhrase[] };

export const LESSONS: Lesson[] = ${JSON.stringify(lessons, null, 2)} as const;
`;

  const outPath = path.join(process.cwd(), "lib", "lessons.generated.ts");
  await fs.writeFile(outPath, output, "utf8");
  console.log(`âœ… Wrote: ${outPath}`);
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});
